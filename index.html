<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Air Golf</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            touch-action: none;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            display: flex;
            flex-direction: column;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        #canvas {
            flex: 1;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
            touch-action: none;
            width: 100%;
        }
        
        #controls {
            padding: 10px 15px;
            background: #333;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-shrink: 0;
        }
        
        button {
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
        }
        
        #setBallBtn {
            padding: 18px 35px;
            font-size: 20px;
            font-weight: bold;
            background: #4CAF50;
            width: 85%;
            max-width: 350px;
            margin-bottom: 8px;
        }
        
        #resetBtn, #settingsBtn {
            padding: 8px 16px;
            font-size: 13px;
            background: #666;
            margin: 3px;
        }
        
        #settingsBtn {
            background: #2196F3;
        }
        
        button:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        /* Settings Modal */
        #settingsModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            overflow-y: auto;
        }
        
        #settingsModal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #settingsPanel {
            background: #333;
            color: white;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #settingsPanel h2 {
            margin-top: 0;
            text-align: center;
            color: #4CAF50;
        }
        
        .setting-group {
            margin: 15px 0;
            padding: 10px;
            background: #444;
            border-radius: 5px;
        }
        
        .setting-group h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #2196F3;
        }
        
        .setting-item {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
        }
        
        .setting-item label {
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .setting-item input[type="number"],
        .setting-item input[type="range"] {
            padding: 8px;
            font-size: 16px;
            background: #555;
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
        }
        
        .setting-item input[type="checkbox"] {
            width: 30px;
            height: 30px;
        }
        
        .range-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .button-group button {
            flex: 1;
            padding: 15px;
            font-size: 16px;
        }
        
        #saveSettingsBtn {
            background: #4CAF50;
        }
        
        #cancelSettingsBtn {
            background: #666;
        }
        
        #status {
            margin: 5px 0;
            font-size: 16px;
            font-weight: bold;
            line-height: 1.3;
            width: 100%;
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            padding: 3px 8px;
            box-sizing: border-box;
        }
        
        #debug {
            font-size: 11px;
            font-family: monospace;
            background: #222;
            padding: 5px;
            margin-top: 5px;
            max-height: 80px;
            overflow-y: auto;
            line-height: 1.2;
            width: 100%;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <button id="setBallBtn">‚õ≥ Tee Up</button>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button id="recordBtn">üé• Record Swing</button>
                <button id="replayBtn" disabled>‚ñ∂Ô∏è Replay</button>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button id="settingsBtn">Settings</button>
                <button id="resetBtn" disabled>Reset</button>
            </div>
            <div id="status">üèåÔ∏è Welcome! Hold your phone like a golf club, then tap "Tee Up"</div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal">
        <div id="settingsPanel">
            <h2>‚öôÔ∏è Settings</h2>
            
            <div class="setting-group">
                <h3>üèåÔ∏è Golf Club</h3>
                <div class="setting-item">
                    <label>Club Length (meters)</label>
                    <input type="number" id="clubLength" min="0.5" max="2.0" step="0.1" value="1.2">
                </div>
                <div class="setting-item">
                    <label>Club Head Weight (grams)</label>
                    <input type="number" id="clubWeight" min="100" max="500" step="10" value="200">
                </div>
                <div class="setting-item">
                    <label>Loft Angle (degrees) <span class="range-value" id="loftValue">25</span></label>
                    <input type="range" id="loftAngle" min="10" max="60" step="1" value="25">
                    <div style="font-size: 11px; color: #aaa; margin-top: 3px;">Driver:10¬∞ | 5-iron:25¬∞ | 9-iron:42¬∞</div>
                </div>
            </div>
            
            <div class="setting-group">
                <h3>üì± Phone Grip</h3>
                <div class="setting-item">
                    <label>Swing Style</label>
                    <select id="phoneOrientation">
                        <option value="edge">üèåÔ∏è Edge First (Like Real Club)</option>
                        <option value="screen">üì± Screen First (Flat Swing)</option>
                    </select>
                    <div style="font-size: 11px; color: #aaa; margin-top: 3px;">
                        Edge First: Hold phone like a golf club shaft<br>
                        Screen First: Swing with screen facing forward
                    </div>
                </div>
            </div>
            
            <div class="setting-group">
                <h3>‚ö™ Golf Ball</h3>
                <div class="setting-item">
                    <label>Ball Diameter (cm)</label>
                    <input type="number" id="ballDiameter" min="3" max="10" step="0.5" value="4.3">
                </div>
                <div class="setting-item">
                    <label>Ball Weight (grams)</label>
                    <input type="number" id="ballWeight" min="30" max="100" step="1" value="45.9">
                </div>
                <div class="setting-item">
                    <label>Hit Zone Diameter (cm)</label>
                    <input type="number" id="hitZoneDiameter" min="5" max="100" step="1" value="30">
                </div>
            </div>
            
            <div class="setting-group">
                <h3>üéØ Hit Detection</h3>
                <div class="setting-item">
                    <label>Position Sensitivity (degrees) <span class="range-value" id="sensitivityValue">15</span></label>
                    <input type="range" id="hitSensitivity" min="5" max="30" step="1" value="15">
                </div>
                <div class="setting-item">
                    <label>Minimum Swing Speed (m/s¬≤) <span class="range-value" id="speedValue">5.0</span></label>
                    <input type="range" id="minSwingSpeed" min="1" max="15" step="0.5" value="5">
                </div>
                <div class="setting-item">
                    <label>Swing Timeout (seconds) <span class="range-value" id="timeoutValue">10</span></label>
                    <input type="range" id="swingTimeout" min="5" max="30" step="1" value="10">
                </div>
            </div>
            
            <div class="setting-group">
                <h3>üåç Physics</h3>
                <div class="setting-item">
                    <label>Gravity (m/s¬≤)</label>
                    <input type="number" id="gravity" min="5" max="15" step="0.1" value="9.81">
                </div>
                <div class="setting-item">
                    <label>Air Resistance Factor <span class="range-value" id="airResValue">0.5</span></label>
                    <input type="range" id="airResistance" min="0" max="1" step="0.1" value="0.5">
                </div>
                <div class="setting-item">
                    <label>Impact Power (Spring Effect) <span class="range-value" id="impactPowerValue">1.5</span></label>
                    <input type="range" id="impactPower" min="0.5" max="3.0" step="0.1" value="1.5">
                    <div style="font-size: 11px; color: #aaa; margin-top: 3px;">
                        0.5 = Soft | 1.5 = Realistic | 3.0 = Super bounce
                    </div>
                </div>
                <div class="setting-item">
                    <label>Spin Effect (Hook/Slice) <span class="range-value" id="spinValue">5</span></label>
                    <input type="range" id="spinEffect" min="0" max="10" step="1" value="5">
                    <div style="font-size: 11px; color: #aaa; margin-top: 3px;">
                        0 = No curve | 5 = Realistic | 10 = Extreme curve
                    </div>
                </div>
            </div>
            
            <div class="setting-group">
                <h3>üñ•Ô∏è Display</h3>
                <div class="setting-item">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="showDebug">
                        Show Debug Info
                    </label>
                </div>
            </div>
            
            <div class="setting-group">
                <h3>üîä Sound</h3>
                <div class="setting-item">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="soundEnabled" checked>
                        Enable Sound Effects
                    </label>
                </div>
                <div class="setting-item">
                    <label>Volume <span class="range-value" id="volumeValue">50</span>%</label>
                    <input type="range" id="soundVolume" min="0" max="100" step="5" value="50">
                </div>
            </div>
            
            <div class="button-group">
                <button id="saveSettingsBtn">Save</button>
                <button id="cancelSettingsBtn">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // GLOBAL STATE MANAGEMENT
        // ============================================
        const GameState = {
            WAITING_PERMISSION: 'waiting_permission',
            READY_TO_SET_BALL: 'ready_to_set_ball',
            BALL_SET_READY_TO_SWING: 'ball_set_ready_to_swing',
            SWINGING: 'swinging',
            BALL_FLYING: 'ball_flying',
            SHOWING_RESULTS: 'showing_results'
        };

        let currentState = GameState.READY_TO_SET_BALL;
        let imuPermissionGranted = false;

        // ============================================
        // SETTINGS CONFIGURATION
        // ============================================
        let settings = {
            phoneOrientation: 'edge',   // 'screen' or 'edge' - which side is the club face
            clubLength: 1.2,        // meters
            clubWeight: 200,        // grams
            ballDiameter: 4.3,      // cm (regulation golf ball)
            ballWeight: 45.9,       // grams
            hitZoneDiameter: 30,    // cm (detection zone diameter)
            hitSensitivity: 15,     // degrees (deprecated - using distance now)
            minSwingSpeed: 5.0,     // m/s¬≤
            loftAngle: 25,          // degrees (club face angle - converts downward swing to upward launch)
            gravity: 9.81,          // m/s¬≤
            airResistance: 0.5,     // factor 0-1
            impactPower: 1.5,       // Coefficient of restitution (club spring effect): 0.5-3.0, realistic is 1.4-1.6
            spinEffect: 5,          // 0-10: how much spin affects trajectory (Magnus effect)
            showDebug: false,       // Hidden by default to save space
            soundEnabled: true,
            soundVolume: 50,        // 0-100
            swingTimeout: 10        // seconds until forced reset
        };

        // ============================================
        // LAST SHOT DATA (for localStorage)
        // ============================================
        let lastShot = {
            distance: 0,
            maxHeight: 0,
            impactSpeed: 0,
            timestamp: null
        };

        // ============================================
        // SWING TIMEOUT TRACKING
        // ============================================
        let swingTimer = {
            startTime: 0,
            timeRemaining: 0,
            expired: false
        };

        // ============================================
        // CLUB TIP TRACKING
        // ============================================
        // PURPOSE: Track the position of the club tip through 3D space
        let clubTipTracking = {
            // Quaternion for orientation (Madgwick filter output)
            quaternion: { w: 1, x: 0, y: 0, z: 0 },
            
            // Club tip position in 3D space (meters from grip)
            tipPosition: { x: 0, y: 0, z: 0 },
            
            // Offset to subtract (set when ball is positioned)
            offset: { x: 0, y: 0, z: 0 },
            
            // Club tip velocity (m/s)
            tipVelocity: { x: 0, y: 0, z: 0 },
            
            // Tracking history for visualization
            history: [],
            
            // Madgwick filter parameters
            beta: 0.1,  // Filter gain (higher = more responsive, more noise)
            
            // Last update timestamp
            lastUpdateTime: 0
        };

        // ============================================
        // PERSPECTIVE PROJECTION (2.5D VIEW)
        // ============================================
        // COORDINATE SYSTEM:
        // X-axis: Left (-) to Right (+)
        // Y-axis: Down (-) to Up (+)  
        // Z-axis: Camera (-) to Fairway (+) - ball flies in +Z direction
        //
        // Camera looking down the fairway (along Z-axis)
        const camera = {
            distance: 4.0,  // meters behind tee (farther for better view)
            height: 2.0,    // meters above ground (higher for better angle)
            fov: 60         // field of view in degrees
        };
        
        const groundLinePercent = 0.70; // Ground at 70% down screen
        
        // Project 3D world coordinates to 2D screen coordinates
        function project3DToScreen(worldX, worldY, worldZ) {
            // Camera is behind the ball, looking forward (+Z direction)
            // worldZ increases as ball flies away
            
            const cameraZ = -camera.distance; // Camera is behind (0,0,0)
            const cameraY = camera.height;
            
            // Relative to camera
            const relX = worldX;
            const relY = worldY - cameraY;
            const relZ = worldZ - cameraZ;
            
            // Prevent division by zero or negative Z (behind camera)
            if (relZ <= 0.1) {
                return { x: canvas.width / 2, y: canvas.height, scale: 0, visible: false };
            }
            
            // Simple perspective projection
            const perspective = 250 / relZ; // Reduced from 300 for less aggressive scaling
            
            const screenX = canvas.width / 2 + relX * perspective;
            
            // Ground is at groundLinePercent down the screen
            const groundLine = canvas.height * groundLinePercent;
            const screenY = groundLine - relY * perspective;
            
            // Check if visible on screen
            const visible = screenX >= -50 && screenX <= canvas.width + 50 &&
                          screenY >= -50 && screenY <= canvas.height + 50;
            
            return { x: screenX, y: screenY, scale: perspective, visible: visible };
        }

        // ============================================
        // DEBUG LOG SYSTEM
        // ============================================
        let debugLog = {
            messages: [],
            maxMessages: 50  // Keep more messages
        };
        
        function addDebugMessage(message) {
            const timestamp = new Date().toLocaleTimeString();
            debugLog.messages.push(`[${timestamp.split(':')[2]}] ${message}`); // Show only seconds
            
            // Keep only last N messages
            if (debugLog.messages.length > debugLog.maxMessages) {
                debugLog.messages.shift();
            }
        }

        // ============================================
        // IMU DATA STORAGE
        // ============================================
        // PURPOSE: Store raw sensor data from device motion events
        let imuData = {
            acceleration: { x: 0, y: 0, z: 0 },      // Linear acceleration (m/s¬≤)
            rotationRate: { alpha: 0, beta: 0, gamma: 0 },  // Angular velocity (deg/s)
            orientation: { alpha: 0, beta: 0, gamma: 0 },    // Device orientation (deg)
            timestamp: 0
        };

        // ============================================
        // BALL POSITION & SWING DATA
        // ============================================
        // PURPOSE: Store the position where user marked the ball and track swing motion
        let ballPosition = {
            orientation: { alpha: 0, beta: 0, gamma: 0 },  // Orientation when ball was set
            timestamp: 0,
            set: false
        };

        let swingData = {
            recordedMotion: [],      // Array of IMU readings during swing
            startTime: 0,
            hitDetected: false,
            hitTime: 0,
            impactVelocity: { x: 0, y: 0, z: 0 }  // Velocity at impact
        };
        
        // ============================================
        // SWING RECORDING & REPLAY
        // ============================================
        let swingRecorder = {
            isRecording: false,
            recordedSwings: [],      // Array of saved swing recordings
            currentRecording: null,  // Current swing being recorded
            replayMode: false,
            replayIndex: 0,          // Which saved swing to replay
            replayProgress: 0,       // Playback position (0-1)
            replaySpeed: 1.0         // Playback speed multiplier
        };

        // ============================================
        // BALL FLIGHT PHYSICS
        // ============================================
        // PURPOSE: Simulate ball trajectory after hit
        let ballFlight = {
            position: { x: 0, y: 0, z: 0 },     // 3D position in world space
            velocity: { x: 0, y: 0, z: 0 },     // Current velocity
            spin: { x: 0, y: 0, z: 0 },         // Spin rate (rad/s) - causes Magnus effect
            flying: false,
            startTime: 0,
            lastUpdateTime: 0,  // For per-frame delta time
            landingDistance: 0,
            maxHeight: 0,
            trajectory: []  // Store path for visualization
        };

        // ============================================
        // UI ELEMENTS
        // ============================================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const setBallBtn = document.getElementById('setBallBtn');
        const resetBtn = document.getElementById('resetBtn');
        const settingsBtn = document.getElementById('settingsBtn');
        const recordBtn = document.getElementById('recordBtn');
        const replayBtn = document.getElementById('replayBtn');
        const statusDiv = document.getElementById('status');
        
        // Settings Modal Elements
        const settingsModal = document.getElementById('settingsModal');
        const saveSettingsBtn = document.getElementById('saveSettingsBtn');
        const cancelSettingsBtn = document.getElementById('cancelSettingsBtn');
        const settingsInputs = {
            phoneOrientation: document.getElementById('phoneOrientation'),
            clubLength: document.getElementById('clubLength'),
            clubWeight: document.getElementById('clubWeight'),
            loftAngle: document.getElementById('loftAngle'),
            ballDiameter: document.getElementById('ballDiameter'),
            ballWeight: document.getElementById('ballWeight'),
            hitZoneDiameter: document.getElementById('hitZoneDiameter'),
            hitSensitivity: document.getElementById('hitSensitivity'),
            minSwingSpeed: document.getElementById('minSwingSpeed'),
            swingTimeout: document.getElementById('swingTimeout'),
            gravity: document.getElementById('gravity'),
            airResistance: document.getElementById('airResistance'),
            impactPower: document.getElementById('impactPower'),
            spinEffect: document.getElementById('spinEffect'),
            showDebug: document.getElementById('showDebug'),
            soundEnabled: document.getElementById('soundEnabled'),
            soundVolume: document.getElementById('soundVolume')
        };

        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Start rendering loop immediately
        requestAnimationFrame(render);

        // ============================================
        // SOUND SYSTEM
        // ============================================
        // PURPOSE: Generate sound effects using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playHitSound() {
            if (!settings.soundEnabled) return;
            
            const now = audioContext.currentTime;
            const volume = settings.soundVolume / 100;
            
            // Create a sharp "crack" sound for club hitting ball
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Sharp percussive sound
            oscillator.frequency.setValueAtTime(800, now);
            oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            oscillator.type = 'triangle';
            
            gainNode.gain.setValueAtTime(volume * 0.5, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            
            oscillator.start(now);
            oscillator.stop(now + 0.15);
        }
        
        function playLandSound() {
            if (!settings.soundEnabled) return;
            
            const now = audioContext.currentTime;
            const volume = settings.soundVolume / 100;
            
            // Create a "thud" sound for ball landing
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Low thud sound
            oscillator.frequency.setValueAtTime(150, now);
            oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.2);
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(volume * 0.4, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
            
            oscillator.start(now);
            oscillator.stop(now + 0.25);
        }
        
        function playAlarmSound() {
            if (!settings.soundEnabled) return;
            
            const now = audioContext.currentTime;
            const volume = settings.soundVolume / 100;
            
            // Create an urgent beeping alarm sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Alternating beep pattern
            oscillator.frequency.setValueAtTime(880, now);
            oscillator.frequency.setValueAtTime(660, now + 0.15);
            oscillator.frequency.setValueAtTime(880, now + 0.3);
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(volume * 0.3, now);
            gainNode.gain.setValueAtTime(0.01, now + 0.1);
            gainNode.gain.setValueAtTime(volume * 0.3, now + 0.15);
            gainNode.gain.setValueAtTime(0.01, now + 0.25);
            gainNode.gain.setValueAtTime(volume * 0.3, now + 0.3);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
            
            oscillator.start(now);
            oscillator.stop(now + 0.45);
        }

        // ============================================
        // LOCAL STORAGE FUNCTIONS
        // ============================================
        // PURPOSE: Save and load settings and last shot data
        
        function saveToLocalStorage() {
            try {
                localStorage.setItem('airGolfSettings', JSON.stringify(settings));
                localStorage.setItem('airGolfLastShot', JSON.stringify(lastShot));
            } catch (e) {
                console.error('Failed to save to localStorage:', e);
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const savedSettings = localStorage.getItem('airGolfSettings');
                const savedLastShot = localStorage.getItem('airGolfLastShot');
                
                if (savedSettings) {
                    const loaded = JSON.parse(savedSettings);
                    // Merge with defaults to handle new settings
                    settings = { ...settings, ...loaded };
                }
                
                if (savedLastShot) {
                    lastShot = JSON.parse(savedLastShot);
                }
            } catch (e) {
                console.error('Failed to load from localStorage:', e);
            }
        }
        
        // Load settings on startup
        loadFromLocalStorage();

        // ============================================
        // MADGWICK FILTER - SENSOR FUSION
        // ============================================
        // PURPOSE: Combine accelerometer and gyroscope data for accurate orientation
        
        function madgwickFilterUpdate(gx, gy, gz, ax, ay, az, dt) {
            // Convert gyroscope degrees/sec to radians/sec
            gx = gx * Math.PI / 180;
            gy = gy * Math.PI / 180;
            gz = gz * Math.PI / 180;
            
            // Short name for quaternion
            let q = clubTipTracking.quaternion;
            
            // Normalize accelerometer measurement
            const norm = Math.sqrt(ax * ax + ay * ay + az * az);
            if (norm === 0) return; // Avoid division by zero
            
            ax /= norm;
            ay /= norm;
            az /= norm;
            
            // Gradient descent algorithm corrective step
            const _2q0 = 2 * q.w;
            const _2q1 = 2 * q.x;
            const _2q2 = 2 * q.y;
            const _2q3 = 2 * q.z;
            const _4q0 = 4 * q.w;
            const _4q1 = 4 * q.x;
            const _4q2 = 4 * q.y;
            const _8q1 = 8 * q.x;
            const _8q2 = 8 * q.y;
            const q0q0 = q.w * q.w;
            const q1q1 = q.x * q.x;
            const q2q2 = q.y * q.y;
            const q3q3 = q.z * q.z;
            
            // Gradient (matrix calculations)
            const s0 = _4q0 * q2q2 + _2q2 * ax + _4q0 * q1q1 - _2q1 * ay;
            const s1 = _4q1 * q3q3 - _2q3 * ax + 4 * q0q0 * q.x - _2q0 * ay - _4q1 + _8q1 * q1q1 + _8q1 * q2q2 + _4q1 * az;
            const s2 = 4 * q0q0 * q.y + _2q0 * ax + _4q2 * q3q3 - _2q3 * ay - _4q2 + _8q2 * q1q1 + _8q2 * q2q2 + _4q2 * az;
            const s3 = 4 * q1q1 * q.z - _2q1 * ax + 4 * q2q2 * q.z - _2q2 * ay;
            
            const sNorm = Math.sqrt(s0 * s0 + s1 * s1 + s2 * s2 + s3 * s3);
            
            // Apply feedback step
            const qDot1 = 0.5 * (-q.x * gx - q.y * gy - q.z * gz) - clubTipTracking.beta * (s0 / sNorm);
            const qDot2 = 0.5 * (q.w * gx + q.y * gz - q.z * gy) - clubTipTracking.beta * (s1 / sNorm);
            const qDot3 = 0.5 * (q.w * gy - q.x * gz + q.z * gx) - clubTipTracking.beta * (s2 / sNorm);
            const qDot4 = 0.5 * (q.w * gz + q.x * gy - q.y * gx) - clubTipTracking.beta * (s3 / sNorm);
            
            // Integrate quaternion rate
            q.w += qDot1 * dt;
            q.x += qDot2 * dt;
            q.y += qDot3 * dt;
            q.z += qDot4 * dt;
            
            // Normalize quaternion
            const qNorm = Math.sqrt(q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z);
            q.w /= qNorm;
            q.x /= qNorm;
            q.y /= qNorm;
            q.z /= qNorm;
        }
        
        // ============================================
        // CLUB TIP POSITION CALCULATION
        // ============================================
        // PURPOSE: Calculate 3D position of club tip based on orientation and club length
        
        function calculateClubTipPosition() {
            const q = clubTipTracking.quaternion;
            const clubLength = settings.clubLength;
            
            // Club points downward from grip in local coordinates
            // Local club direction: (0, -clubLength, 0) in grip's reference frame
            const localX = 0;
            const localY = -clubLength;
            const localZ = 0;
            
            // Rotate local club vector by quaternion to get world position
            // q * v * q_conjugate
            const ix = q.w * localX + q.y * localZ - q.z * localY;
            const iy = q.w * localY + q.z * localX - q.x * localZ;
            const iz = q.w * localZ + q.x * localY - q.y * localX;
            const iw = -q.x * localX - q.y * localY - q.z * localZ;
            
            let tipX = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;
            let tipY = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;
            let tipZ = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
            
            // Apply phone orientation transformation
            if (settings.phoneOrientation === 'edge') {
                // Edge-first: Same rotation as velocity
                // Phone X ‚Üí Screen Z, Phone Y ‚Üí Screen X, Phone Z ‚Üí Screen Y
                const tempX = tipX;
                const tempY = tipY;
                const tempZ = tipZ;
                
                tipX = tempY;   // Phone Y ‚Üí Screen X
                tipY = -tempZ;  // Phone Z ‚Üí Screen Y (inverted)
                tipZ = tempX;   // Phone X ‚Üí Screen Z
            }
            // For 'screen' orientation, no transformation needed (original behavior)
            
            // Offset so tip starts at (0,0,0) instead of (0, -clubLength, 0)
            // Add clubLength to Y so initial position is at origin
            // Then subtract the offset that was stored when ball was set
            clubTipTracking.tipPosition.x = tipX - clubTipTracking.offset.x;
            clubTipTracking.tipPosition.y = (tipY + clubLength) - clubTipTracking.offset.y;
            clubTipTracking.tipPosition.z = tipZ - clubTipTracking.offset.z;
        }
        
        // ============================================
        // CLUB TIP TRACKING UPDATE
        // ============================================
        // PURPOSE: Update club tip tracking with new IMU data
        
        function updateClubTipTracking() {
            const now = Date.now();
            
            // Calculate time delta
            if (clubTipTracking.lastUpdateTime === 0) {
                clubTipTracking.lastUpdateTime = now;
                return;
            }
            
            const dt = (now - clubTipTracking.lastUpdateTime) / 1000; // Convert to seconds
            clubTipTracking.lastUpdateTime = now;
            
            // Skip if dt is too large (first frame or tab was inactive)
            if (dt > 0.1) return;
            
            // Update orientation using Madgwick filter
            madgwickFilterUpdate(
                imuData.rotationRate.alpha || 0,
                imuData.rotationRate.beta || 0,
                imuData.rotationRate.gamma || 0,
                imuData.acceleration.x || 0,
                imuData.acceleration.y || 0,
                imuData.acceleration.z || 0,
                dt
            );
            
            // Calculate club tip position from orientation
            calculateClubTipPosition();
            
            // Store in history for visualization
            clubTipTracking.history.push({
                position: { ...clubTipTracking.tipPosition },
                timestamp: now
            });
            
            // Record for swing replay if recording is active
            if (swingRecorder.isRecording && swingRecorder.currentRecording && ballPosition.set) {
                swingRecorder.currentRecording.tipPath.push({
                    position: { ...clubTipTracking.tipPosition },
                    velocity: { ...clubTipTracking.tipVelocity },
                    timestamp: now
                });
            }
            
            // Keep only last 2 seconds of history
            const twoSecondsAgo = now - 2000;
            clubTipTracking.history = clubTipTracking.history.filter(
                h => h.timestamp > twoSecondsAgo
            );
            
            // Debug: Show tip position every 30 frames when ball is set (about every 0.5 sec)
            if (ballPosition.set && clubTipTracking.history.length % 30 === 0) {
                const tipDist = Math.sqrt(
                    clubTipTracking.tipPosition.x ** 2 +
                    clubTipTracking.tipPosition.y ** 2 +
                    clubTipTracking.tipPosition.z ** 2
                );
                addDebugMessage(`Tip: [${clubTipTracking.tipPosition.x.toFixed(2)}, ${clubTipTracking.tipPosition.y.toFixed(2)}, ${clubTipTracking.tipPosition.z.toFixed(2)}] d:${tipDist.toFixed(2)}m`);
            }
        }

        // ============================================
        // PART 1: IMU PERMISSION & DATA COLLECTION
        // ============================================
        // PURPOSE: Request permission for device motion sensors (iOS 13+)
        // and start collecting IMU data

        async function requestIMUPermission() {
            updateStatus('Requesting IMU permission...');
            
            // TODO: Implement iOS permission request
            // Check if DeviceMotionEvent.requestPermission exists (iOS 13+)
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceMotionEvent.requestPermission();
                    if (permission === 'granted') {
                        initializeIMU();
                        return true;
                    } else {
                        updateStatus('ERROR: IMU permission denied');
                        return false;
                    }
                } catch (error) {
                    updateStatus('ERROR: ' + error.message);
                    return false;
                }
            } else {
                // Non-iOS devices or older iOS
                initializeIMU();
                return true;
            }
        }

        function initializeIMU() {
            // TODO: Start listening to device motion events
            window.addEventListener('devicemotion', handleDeviceMotion);
            window.addEventListener('deviceorientation', handleDeviceOrientation);
            
            imuPermissionGranted = true;
            currentState = GameState.READY_TO_SET_BALL;
            
            resetBtn.disabled = false;
            
            updateStatus('‚úì IMU Ready! Set ball position to start');
        }

        // ============================================
        // PART 2: IMU DATA HANDLERS
        // ============================================
        // PURPOSE: Collect and store raw IMU data from device sensors
        function handleDeviceMotion(event) {
            // TODO: Process device motion data
            // Store acceleration and rotation rate
            if (event.acceleration) {
                imuData.acceleration = {
                    x: event.acceleration.x || 0,
                    y: event.acceleration.y || 0,
                    z: event.acceleration.z || 0
                };
            }
            
            if (event.rotationRate) {
                imuData.rotationRate = {
                    alpha: event.rotationRate.alpha || 0,
                    beta: event.rotationRate.beta || 0,
                    gamma: event.rotationRate.gamma || 0
                };
            }
            
            imuData.timestamp = event.timeStamp || Date.now();
            
            // Update club tip tracking if ball is set or swinging
            if (currentState === GameState.BALL_SET_READY_TO_SWING || 
                currentState === GameState.SWINGING) {
                updateClubTipTracking();
            }
            
            // If we're in swinging state, record the motion
            if (currentState === GameState.SWINGING) {
                recordSwingMotion();
            }
        }

        function handleDeviceOrientation(event) {
            // TODO: Store device orientation
            imuData.orientation = {
                alpha: event.alpha || 0,  // Rotation around z-axis (0-360)
                beta: event.beta || 0,    // Rotation around x-axis (-180 to 180)
                gamma: event.gamma || 0   // Rotation around y-axis (-90 to 90)
            };
        }

        // ============================================
        // PART 3: BALL POSITION SETTING
        // ============================================
        // PURPOSE: Mark the current phone position as the ball's location
        setBallBtn.addEventListener('click', async function() {
            // First check if we need to request IMU permission
            if (!imuPermissionGranted) {
                const granted = await requestIMUPermission();
                if (!granted) return; // Permission denied, exit
            }
            
            // Now set the ball position
            setBallPosition();
        });

        function setBallPosition() {
            // TODO: Record current orientation as ball position
            // This is the reference point for detecting when club returns to hit ball
            ballPosition = {
                orientation: { ...imuData.orientation },
                timestamp: Date.now(),
                set: true
            };
            
            // Calculate current tip position BEFORE resetting
            calculateClubTipPosition();
            
            // Store current position as offset (so future positions are relative to this)
            clubTipTracking.offset = {
                x: clubTipTracking.tipPosition.x + clubTipTracking.offset.x,
                y: clubTipTracking.tipPosition.y + clubTipTracking.offset.y,
                z: clubTipTracking.tipPosition.z + clubTipTracking.offset.z
            };
            
            // Now recalculate - tip should be at (0,0,0)
            calculateClubTipPosition();
            
            // Clear history
            clubTipTracking.history = [];
            clubTipTracking.lastUpdateTime = Date.now();
            
            // Start swing timeout timer
            swingTimer.startTime = Date.now();
            swingTimer.timeRemaining = settings.swingTimeout;
            swingTimer.expired = false;
            
            currentState = GameState.BALL_SET_READY_TO_SWING;
            setBallBtn.disabled = true;
            updateStatus('‚úì Ball Set! Swing now!');
            
            // Start swing recording if enabled
            if (swingRecorder.isRecording) {
                swingRecorder.currentRecording = {
                    tipPath: [],        // Club tip positions
                    startTime: Date.now(),
                    ballPosition: { ...ballPosition },
                    settings: { ...settings }
                };
                addDebugMessage(`üé• Recording swing...`);
            }
            
            // Debug
            addDebugMessage(`‚ö™ Ball set! Tip at [${clubTipTracking.tipPosition.x.toFixed(3)}, ${clubTipTracking.tipPosition.y.toFixed(3)}, ${clubTipTracking.tipPosition.z.toFixed(3)}]`);
            addDebugMessage(`üì± Grip: ${settings.phoneOrientation === 'edge' ? 'Edge First üèåÔ∏è' : 'Screen First üì±'}`);
            addDebugMessage(`Offset: [${clubTipTracking.offset.x.toFixed(3)}, ${clubTipTracking.offset.y.toFixed(3)}, ${clubTipTracking.offset.z.toFixed(3)}]`);
            
            // TODO: Start monitoring for swing motion
            startSwingDetection();
        }

        // ============================================
        // PART 4: SWING DETECTION
        // ============================================
        // PURPOSE: Detect when user starts swinging and when club hits ball
        function startSwingDetection() {
            // TODO: Monitor for significant movement indicating swing started
            swingData.recordedMotion = [];
            swingData.startTime = Date.now();
            swingData.hitDetected = false;
            
            currentState = GameState.SWINGING;
        }

        function recordSwingMotion() {
            // TODO: Store IMU data during swing
            swingData.recordedMotion.push({
                acceleration: { ...imuData.acceleration },
                rotationRate: { ...imuData.rotationRate },
                orientation: { ...imuData.orientation },
                timestamp: imuData.timestamp
            });
            
            // Keep only last 2 seconds of data to avoid memory issues
            const twoSecondsAgo = Date.now() - 2000;
            swingData.recordedMotion = swingData.recordedMotion.filter(
                d => d.timestamp > twoSecondsAgo
            );
            
            // Check for timeout
            checkSwingTimeout();
            
            // TODO: Check if club has returned to ball position (hit detected)
            if (!swingTimer.expired) {
                detectBallHit();
            }
        }
        
        function checkSwingTimeout() {
            if (swingTimer.expired) return;
            
            const elapsed = (Date.now() - swingTimer.startTime) / 1000; // Convert to seconds
            swingTimer.timeRemaining = Math.max(0, settings.swingTimeout - elapsed);
            
            if (swingTimer.timeRemaining <= 0) {
                swingTimer.expired = true;
                handleSwingTimeout();
            }
        }
        
        function handleSwingTimeout() {
            // Play alarm sound
            playAlarmSound();
            
            // Cancel current recording (swing timed out - no hit)
            if (swingRecorder.isRecording && swingRecorder.currentRecording) {
                addDebugMessage(`üé• Recording canceled (timeout)`);
                swingRecorder.currentRecording = null;
            }
            
            // Force reset
            currentState = GameState.READY_TO_SET_BALL;
            ballPosition.set = false;
            swingData.recordedMotion = [];
            swingData.hitDetected = false;
            setBallBtn.disabled = false;
            
            updateStatus('‚è∞ TIMEOUT! Set ball position again');
        }

        function detectBallHit() {
            // PURPOSE: Detect when club tip returns to ball position with sufficient velocity
            // Uses kinematic constraints and ZUPT (Zero-Velocity Update) principles
            
            if (swingData.hitDetected) return;
            
            // Calculate distance of club tip from ball (which is at origin 0,0,0)
            const tipDistance = Math.sqrt(
                clubTipTracking.tipPosition.x ** 2 +
                clubTipTracking.tipPosition.y ** 2 +
                clubTipTracking.tipPosition.z ** 2
            );
            
            // Hit threshold from settings (convert cm to meters)
            const hitThreshold = settings.hitZoneDiameter / 200; // Diameter to radius, cm to m
            
            // Calculate club tip velocity magnitude
            const totalAcceleration = Math.sqrt(
                imuData.acceleration.x ** 2 +
                imuData.acceleration.y ** 2 +
                imuData.acceleration.z ** 2
            );
            
            // Debug: log when close to hit zone
            if (tipDistance < hitThreshold * 1.5) {
                addDebugMessage(`Near! dist:${tipDistance.toFixed(3)}m thresh:${hitThreshold.toFixed(3)}m accel:${totalAcceleration.toFixed(1)}`);
            }
            
            // Detect hit: club tip is near ball AND moving fast
            if (tipDistance < hitThreshold && totalAcceleration > settings.minSwingSpeed) {
                // Additional check: ensure club has moved away first (backswing)
                // Check history to see if club was far away recently
                const recentHistory = clubTipTracking.history.slice(-20); // Last 20 samples
                const maxDistance = Math.max(...recentHistory.map(h => 
                    Math.sqrt(h.position.x ** 2 + h.position.y ** 2 + h.position.z ** 2)
                ));
                
                addDebugMessage(`HIT CHECK: dist:${tipDistance.toFixed(3)} backswing:${maxDistance.toFixed(3)}`);
                
                // Only register hit if club moved away at least 15cm before returning
                if (maxDistance > 0.15) {
                    registerBallHit();
                } else {
                    addDebugMessage(`REJECTED: backswing too small (need >0.15m)`);
                }
            }
        }

        function registerBallHit() {
            // TODO: Calculate impact velocity from swing data
            swingData.hitDetected = true;
            swingData.hitTime = Date.now();
            
            addDebugMessage(`üí• HIT REGISTERED!`);
            
            // PLACEHOLDER: Calculate velocity at impact
            swingData.impactVelocity = calculateImpactVelocity();
            
            // Store impact speed for results
            lastShot.impactSpeed = Math.sqrt(
                swingData.impactVelocity.x ** 2 +
                swingData.impactVelocity.y ** 2 +
                swingData.impactVelocity.z ** 2
            );
            
            // Play hit sound
            playHitSound();
            
            // Save recorded swing if recording was active
            if (swingRecorder.isRecording && swingRecorder.currentRecording) {
                swingRecorder.currentRecording.endTime = Date.now();
                swingRecorder.currentRecording.impactVelocity = { ...swingData.impactVelocity };
                swingRecorder.currentRecording.distance = 0; // Will be updated when ball lands
                swingRecorder.recordedSwings.push(swingRecorder.currentRecording);
                addDebugMessage(`üé• Swing saved! Total: ${swingRecorder.recordedSwings.length}`);
                replayBtn.disabled = false; // Enable replay button
                swingRecorder.currentRecording = null;
            }
            
            currentState = GameState.BALL_FLYING;
            updateStatus('üèåÔ∏è HIT! Ball is flying...');
            
            // TODO: Start ball flight simulation
            launchBall(swingData.impactVelocity);
        }

        function calculateImpactVelocity() {
            // ====================================================================
            // PHYSICS: Calculate ball's initial velocity from club tip motion
            // ====================================================================
            // Method: Finite difference - v = Œîposition / Œîtime
            // Units: Input = meters (position), Output = m/s (velocity)
            // 
            // Real golf physics reference:
            // - Pro club head speed: 45-55 m/s (100-120 mph)
            // - Ball speed at impact: 65-75 m/s (145-170 mph) 
            // - Speed ratio (ball/club): ~1.5x (due to club face spring effect)
            // - Typical carry distance: 220-280 meters
            // ====================================================================
            
            const history = clubTipTracking.history;
            if (history.length < 5) {
                // Fallback to acceleration-based estimate
                // WARNING: This is a rough approximation!
                const fallback = {
                    x: imuData.acceleration.x * 5,
                    y: imuData.acceleration.y * 5,
                    z: imuData.acceleration.z * 5
                };
                addDebugMessage(`VEL: Using fallback (hist short)`);
                return fallback;
            }
            
            // Get last few samples (smoother estimate)
            // Using 5 frame difference to reduce noise
            const current = history[history.length - 1];
            const previous = history[history.length - 5];
            
            const dt = (current.timestamp - previous.timestamp) / 1000; // Convert ms to seconds
            
            if (dt === 0) {
                addDebugMessage(`VEL: dt=0!`);
                return { x: 0, y: 0, z: 0 };
            }
            
            // ====================================================================
            // STEP 1: Calculate raw velocity in phone coordinates
            // ====================================================================
            // Œîposition = current - previous (meters)
            // velocity = Œîposition / Œîtime (m/s)
            // ====================================================================
            
            const deltaX = current.position.x - previous.position.x;  // meters
            const deltaY = current.position.y - previous.position.y;  // meters
            const deltaZ = current.position.z - previous.position.z;  // meters
            
            addDebugMessage(`ŒîPos: [${deltaX.toFixed(3)}, ${deltaY.toFixed(3)}, ${deltaZ.toFixed(3)}] in ${dt.toFixed(3)}s`);
            
            // Calculate velocity using finite difference
            let vx = deltaX / dt;  // m/s in phone X direction
            let vy = deltaY / dt;  // m/s in phone Y direction
            let vz = deltaZ / dt;  // m/s in phone Z direction
            
            addDebugMessage(`Raw phone vel: x:${vx.toFixed(2)} y:${vy.toFixed(2)} z:${vz.toFixed(2)} m/s`);
            
            // ====================================================================
            // STEP 2: Transform phone coordinates ‚Üí screen/world coordinates
            // ====================================================================
            // Depends on how user holds phone (edge-first vs screen-first)
            // ====================================================================
            
            if (settings.phoneOrientation === 'edge') {
                // Edge-first: When holding phone like golf club (edge pointing forward)
                // Phone X-axis (along long edge) = swing direction ‚Üí Screen Z (forward)
                // Phone Y-axis (screen normal) = left/right ‚Üí Screen X
                // Phone Z-axis (top to bottom) = up/down ‚Üí Screen Y
                const tempX = vx;
                const tempY = vy;
                const tempZ = vz;
                
                vx = tempY;   // Phone Y (screen normal) ‚Üí Screen X (left/right)
                vy = -tempZ;  // Phone Z (top/bottom) ‚Üí Screen Y (up/down), inverted
                vz = tempX;   // Phone X (long edge) ‚Üí Screen Z (forward/back)
                
                addDebugMessage(`üì± Edge: PhoneX‚ÜíScreenZ, PhoneY‚ÜíScreenX, PhoneZ‚ÜíScreenY`);
                addDebugMessage(`üì± After rot: [${vx.toFixed(2)}, ${vy.toFixed(2)}, ${vz.toFixed(2)}] m/s`);
            }
            
            addDebugMessage(`Screen vel: x:${vx.toFixed(2)} y:${vy.toFixed(2)} z:${vz.toFixed(2)} m/s`);
            
            // ====================================================================
            // STEP 3: Apply LOFT ANGLE transformation
            // ====================================================================
            // Real golf: Club face has loft angle (10-60¬∞)
            // Downward club motion + loft = upward ball flight
            // Physics: Decompose club velocity into components based on loft
            // ====================================================================
            
            const loftRadians = settings.loftAngle * Math.PI / 180;
            
            // Calculate horizontal speed (forward motion in XZ plane)
            const horizontalSpeed = Math.sqrt(vx * vx + vz * vz);  // m/s
            
            // If club is moving down (negative vy), loft redirects it upward
            // Formula: vyBall = horizontalSpeed * sin(loft) + |vyClub| * cos(loft)
            // This mimics the club face angle redirecting energy
            let vyLofted;
            if (vy < 0) {
                // Downward swing - apply loft
                vyLofted = horizontalSpeed * Math.sin(loftRadians) + Math.abs(vy) * Math.cos(loftRadians);
                addDebugMessage(`Loft applied: ${vy.toFixed(2)} ‚Üí ${vyLofted.toFixed(2)} (${settings.loftAngle}¬∞)`);
            } else {
                // Already upward - keep it
                vyLofted = vy;
                addDebugMessage(`No loft needed (Y already positive)`);
            }
            
            // ====================================================================
            // STEP 4: Apply SCALING FACTORS (NOW FIXED!)
            // ====================================================================
            // REAL PHYSICS: Ball speed / club speed ‚âà 1.5x (due to club elasticity)
            // 
            // Breakdown of each factor:
            // ====================================================================
            
            const weightFactor = settings.clubWeight / 200;          
            // Heavier club = more momentum transfer
            // For standard 200g club head: factor = 1.0
            // Range: 0.5 - 2.5x for realistic club weights (100-500g)
            
            const leverEffect = 1.0;  
            // ‚úÖ FIXED: Was 4.0, now 1.0
            // We're already tracking club TIP velocity directly!
            // The leverage effect (club length amplification) is already included
            // in the tip position tracking via quaternion rotation
            
            const energyTransferFactor = settings.impactPower;  
            // This represents the coefficient of restitution (springiness)
            // Real golf: club face spring effect ‚âà 1.4-1.5x
            // User adjustable for game feel (1-3 realistic range)
            // Default changed to 1.5 for realistic physics
            
            const totalScale = weightFactor * leverEffect * energyTransferFactor;
            // TOTAL MULTIPLICATION = 1.0 * 1.0 * 1.5 = 1.5x (realistic!)
            // 
            // Example: If club tip moves at 40 m/s (fast amateur swing)
            // Ball velocity becomes: 40 * 1.5 = 60 m/s (realistic pro level!)
            // Expected distance: 220-280 meters
            // ====================================================================
            
            addDebugMessage(`Scale: ${totalScale.toFixed(1)}x ‚úì`);
            
            // ====================================================================
            // STEP 5: Ensure ball flies AWAY from player (positive Z)
            // ====================================================================
            
            const horizontalXZ = Math.sqrt(vx ** 2 + vz ** 2);
            const scaledZ = vz * totalScale;
            
            // The ball should fly in the direction of the swing
            // Force Z to be positive (away from camera)
            let finalVz;
            
            if (horizontalXZ > 0.1) {
                if (Math.abs(vz) > Math.abs(vx)) {
                    // Z is dominant swing direction
                    finalVz = Math.abs(scaledZ); // Always positive (away)
                    addDebugMessage(`Z dominant: forcing AWAY (${finalVz.toFixed(1)} m/s)`);
                } else {
                    // X is dominant - ensure Z is still forward
                    finalVz = Math.abs(scaledZ);
                    addDebugMessage(`X dominant: Z set to AWAY (${finalVz.toFixed(1)} m/s)`);
                }
            } else {
                // Very little horizontal motion
                finalVz = Math.abs(scaledZ);
                addDebugMessage(`Low motion: Z forced AWAY (${finalVz.toFixed(1)} m/s)`);
            }
            
            // ====================================================================
            // FINAL: Return ball's initial velocity vector
            // ====================================================================
            // Units: m/s (meters per second)
            // Expected realistic range: 10-75 m/s total velocity
            // ====================================================================
            
            const result = {
                x: vx * totalScale,           // m/s (left/right)
                y: vyLofted * totalScale,     // m/s (up/down)
                z: finalVz                    // m/s (forward/back)
            };
            
            const totalVel = Math.sqrt(result.x ** 2 + result.y ** 2 + result.z ** 2);
            addDebugMessage(`IMPACT: ${totalVel.toFixed(1)}m/s [x:${result.x.toFixed(1)}, y:${result.y.toFixed(1)}, z:${result.z.toFixed(1)}]`);
            
            // ‚ö†Ô∏è SANITY CHECK: Warn if velocity seems unrealistic
            if (totalVel > 80) {
                addDebugMessage(`‚ö†Ô∏è VELOCITY HIGH! ${totalVel.toFixed(0)}m/s (pro level is 60-75)`);
            } else if (totalVel < 5) {
                addDebugMessage(`‚ö†Ô∏è VELOCITY LOW! ${totalVel.toFixed(0)}m/s (swing harder!)`);
            }
            
            return result;
        }

        // ============================================
        // PART 5: BALL FLIGHT PHYSICS
        // ============================================
        // PURPOSE: Simulate realistic ball trajectory with gravity and air resistance
        function launchBall(initialVelocity) {
            // ====================================================================
            // PHYSICS: Initialize ball flight with impact velocity
            // ====================================================================
            // Input: initialVelocity (m/s) from calculateImpactVelocity()
            // This function:
            // 1. Applies ball weight factor (lighter balls fly farther)
            // 2. Calculates spin from impact velocity
            // 3. Initializes flight state
            // ====================================================================
            
            // Ball weight affects distance
            // Lighter ball = less inertia = flies farther with same impact
            // Real golf: Ball weight is regulated at 45.93g (¬±0.05g)
            const ballWeightFactor = 45.9 / settings.ballWeight; // Normalized to regulation
            
            let vx = initialVelocity.x * ballWeightFactor;  // m/s
            let vy = initialVelocity.y * ballWeightFactor;  // m/s
            let vz = initialVelocity.z * ballWeightFactor;  // m/s
            
            addDebugMessage(`üîß Launch V: [${vx.toFixed(1)}, ${vy.toFixed(1)}, ${vz.toFixed(1)}] m/s`);
            
            // ====================================================================
            // SPIN CALCULATION: Convert impact velocity to ball spin
            // ====================================================================
            // Spin causes Magnus force ‚Üí ball curves in flight
            // Real golf spin rates:
            // - Driver: 2000-3000 rpm (209-314 rad/s) backspin
            // - Iron: 5000-9000 rpm (523-942 rad/s) backspin
            // - Sidespin (hook/slice): 100-500 rpm (10-52 rad/s)
            // ====================================================================
            
            const ballRadius = (settings.ballDiameter / 100) / 2; // Convert cm to meters
            
            // Safety check - prevent division by zero or invalid values
            if (ballRadius <= 0 || !isFinite(vx) || !isFinite(vy) || !isFinite(vz)) {
                addDebugMessage(`‚ö†Ô∏è Invalid velocity or ball size, skipping spin`);
                ballFlight.spin = { x: 0, y: 0, z: 0 };
            } else {
                // ================================================================
                // Sidespin calculation (hook/slice)
                // ================================================================
                // Physics: Sideways club motion ‚Üí spin around Y-axis
                // Formula: œâ = v / r (simplified - assumes rolling contact)
                // 
                // Spin direction (right-hand rule around Y-axis):
                // - Positive X velocity (right-to-left swing) ‚Üí slice (right curve)
                // - Negative X velocity (left-to-right swing) ‚Üí hook (left curve)
                // 
                // Coefficient 0.02: Reduces spin rate to realistic levels
                // ================================================================
                
                const sidespinRate = -(vx / ballRadius) * 0.02; // rad/s
                
                // ================================================================
                // Backspin calculation
                // ================================================================
                // Physics: Upward club motion + loft ‚Üí backspin
                // More upward velocity = more backspin = more lift = longer carry
                // 
                // Coefficient 0.05: Scales velocity to realistic spin rates
                // ================================================================
                
                const backspinRate = (vy / ballRadius) * 0.05; // rad/s
                
                // Riflespin: Minimal in golf (ignored)
                const riflespinRate = 0;
                
                // Ensure spin values are valid (no NaN, no Infinity)
                ballFlight.spin = { 
                    x: isFinite(backspinRate) ? backspinRate : 0,   // Backspin
                    y: isFinite(sidespinRate) ? sidespinRate : 0,   // Hook/Slice
                    z: isFinite(riflespinRate) ? riflespinRate : 0  // Riflespin
                };
            }
            
            const spinMagnitude = Math.sqrt(
                ballFlight.spin.x**2 + ballFlight.spin.y**2
            );
            
            // Show spin debug only if significant and spinEffect > 0
            if (settings.spinEffect > 0 && spinMagnitude > 5) {
                addDebugMessage(`üåÄ Spin: ${spinMagnitude.toFixed(0)} rad/s`);
                
                if (Math.abs(ballFlight.spin.y) > 50) {
                    const direction = ballFlight.spin.y < 0 ? 'SLICE‚Üí' : '‚ÜêHOOK';
                    addDebugMessage(`üåÄ ${direction}`);
                }
            }
            
            // ====================================================================
            // Initialize flight state
            // ====================================================================
            
            ballFlight.position = { x: 0, y: 0, z: 0 };  // Start at origin (ground level)
            ballFlight.velocity = { x: vx, y: vy, z: vz };  // m/s
            // Spin already set above in safety-checked section
            ballFlight.flying = true;
            ballFlight.startTime = Date.now();
            ballFlight.lastUpdateTime = Date.now();
            ballFlight.maxHeight = 0;
            ballFlight.trajectory = [{ x: 0, y: 0, z: 0 }];  // Start trajectory
            
            // Store in lastShot for persistent HUD display
            lastShot.velocity = { x: vx, y: vy, z: vz };
            lastShot.spin = { x: ballFlight.spin.x, y: ballFlight.spin.y, z: ballFlight.spin.z };
            lastShot.timestamp = Date.now();
            
            // ====================================================================
            // Verification: Check launch parameters
            // ====================================================================
            
            const totalVel = Math.sqrt(
                ballFlight.velocity.x ** 2 +
                ballFlight.velocity.y ** 2 +
                ballFlight.velocity.z ** 2
            );
            addDebugMessage(`üèåÔ∏è LAUNCH! ${totalVel.toFixed(1)}m/s`);
            addDebugMessage(`V: [${ballFlight.velocity.x.toFixed(1)}, ${ballFlight.velocity.y.toFixed(1)}, ${ballFlight.velocity.z.toFixed(1)}]`);
            
            // CRITICAL: Verify launch direction
            if (ballFlight.velocity.y <= 0) {
                addDebugMessage(`‚ö†Ô∏è Y velocity ${ballFlight.velocity.y.toFixed(1)} ‚â§ 0! Ball won't go up!`);
            } else {
                addDebugMessage(`‚úì Y velocity ${ballFlight.velocity.y.toFixed(1)} is UP`);
            }
            
            if (ballFlight.velocity.z <= 0) {
                addDebugMessage(`‚ö†Ô∏è Z velocity ${ballFlight.velocity.z.toFixed(1)} ‚â§ 0! Ball coming TOWARD you!`);
            } else {
                addDebugMessage(`‚úì Z velocity ${ballFlight.velocity.z.toFixed(1)} is AWAY`);
            }
        }

        function updateBallPhysics(deltaTime) {
            // ====================================================================
            // PHYSICS: Update ball position and velocity during flight
            // ====================================================================
            // Called every frame (60 FPS typical)
            // Simulates:
            // 1. Gravity (constant downward acceleration)
            // 2. Magnus force (spin-induced curve)
            // 3. Air resistance (drag)
            // 4. Position update (velocity integration)
            // 5. Ground collision detection
            // 
            // Real golf ball flight:
            // - Flight time: 4-7 seconds
            // - Max height: 20-40 meters
            // - Carry distance: 150-300 meters (pros)
            // - Air time vs distance ratio: ~15ms per meter
            // ====================================================================
            
            if (!ballFlight.flying) return;
            
            const dt = deltaTime / 1000; // Convert milliseconds to seconds
            
            // Skip huge time deltas (first frame or tab was inactive)
            // Large dt would cause physics instability (ball teleporting)
            if (dt > 0.1) {
                addDebugMessage(`Skip physics: dt=${dt.toFixed(2)}s too large`);
                return;
            }
            
            // ====================================================================
            // GRAVITY: Constant downward acceleration
            // ====================================================================
            // F = ma  ‚Üí  a = g = 9.81 m/s¬≤ (Earth standard)
            // v(t+dt) = v(t) + a*dt
            // ====================================================================
            
            const gravity = -settings.gravity; // m/s¬≤ (negative = downward)
            
            // Update velocity with gravity
            ballFlight.velocity.y += gravity * dt;  // m/s
            
            // ====================================================================
            // MAGNUS FORCE: Spin creates aerodynamic force perpendicular to motion
            // ====================================================================
            // Physics: Spinning ball drags air around it ‚Üí pressure differential
            // Formula: F_magnus = C_L * œâ √ó v
            // Where:
            // - C_L: Lift coefficient (depends on ball properties, air density)
            // - œâ: Angular velocity vector (spin rate, rad/s)
            // - v: Linear velocity vector (m/s)
            // 
            // Cross product œâ √ó v gives force direction (right-hand rule)
            // 
            // Real golf Magnus effect:
            // - Backspin: Creates lift, increases carry distance
            // - Sidespin: Creates sideways force, causes hook/slice
            // - Typical curve: 5-30 meters lateral deviation
            // ====================================================================
            
            if (settings.spinEffect > 0 && ballFlight.spin) {
                // ================================================================
                // Magnus coefficient tuning
                // ================================================================
                // Realistic C_L for golf ball ‚âà 0.25 - 0.35
                // Our spinFactor = settings.spinEffect * 0.00001
                // 
                // At spinEffect=5 (realistic):
                // spinFactor = 5 * 0.00001 = 0.00005
                // 
                // For typical values:
                // - Spin: 200 rad/s
                // - Velocity: 50 m/s
                // - Magnus accel: 0.00005 * 200 * 50 = 0.5 m/s¬≤
                // - Over 5 seconds: lateral velocity change ‚âà 2.5 m/s
                // - Lateral displacement: ‚âà 6 meters (realistic!)
                // ================================================================
                
                const spinFactor = settings.spinEffect * 0.00001;
                
                // Cross product: œâ √ó v
                // Spin is in rad/s, velocity is in m/s
                // Result is acceleration in m/s¬≤
                const magnusX = spinFactor * (
                    ballFlight.spin.y * ballFlight.velocity.z - 
                    ballFlight.spin.z * ballFlight.velocity.y
                );
                const magnusY = spinFactor * (
                    ballFlight.spin.z * ballFlight.velocity.x - 
                    ballFlight.spin.x * ballFlight.velocity.z
                );
                const magnusZ = spinFactor * (
                    ballFlight.spin.x * ballFlight.velocity.y - 
                    ballFlight.spin.y * ballFlight.velocity.x
                );
                
                // Apply Magnus acceleration to velocity
                if (isFinite(magnusX)) ballFlight.velocity.x += magnusX * dt;
                if (isFinite(magnusY)) ballFlight.velocity.y += magnusY * dt;
                if (isFinite(magnusZ)) ballFlight.velocity.z += magnusZ * dt;
                
                // Log Magnus effect in first 500ms
                const timeSinceLaunch = Date.now() - ballFlight.startTime;
                if (timeSinceLaunch < 500 && (magnusX !== 0 || magnusZ !== 0)) {
                    addDebugMessage(`üåÄ Magnus: X${magnusX > 0 ? '+' : ''}${magnusX.toFixed(2)} m/s¬≤`);
                }
                
                // Spin decays due to air friction
                // Real golf: spin decays by ~20% over flight
                const spinDecay = 0.98; // Per frame (0.98^60 ‚âà 0.3 after 1 second)
                ballFlight.spin.x *= spinDecay;
                ballFlight.spin.y *= spinDecay;
                ballFlight.spin.z *= spinDecay;
            }
            
            // ====================================================================
            // AIR RESISTANCE (Drag): Opposes motion, proportional to velocity¬≤
            // ====================================================================
            // Physics: F_drag = 0.5 * œÅ * C_d * A * v¬≤
            // Where:
            // - œÅ: Air density (~1.225 kg/m¬≥ at sea level)
            // - C_d: Drag coefficient (~0.25-0.5 for golf ball)
            // - A: Cross-sectional area
            // - v: Velocity
            // 
            // Simplified: v_new = v_old * (1 - dragFactor)
            // dragFactor scales with settings.airResistance (0-1)
            // 
            // Real effect: Reduces carry by 10-20% vs vacuum
            // ====================================================================
            
            if (settings.airResistance > 0) {
                const dragFactor = settings.airResistance * 0.01; // Scale factor
                
                // Apply drag to horizontal motion
                ballFlight.velocity.x *= (1 - dragFactor);
                ballFlight.velocity.z *= (1 - dragFactor);
                
                // Y-axis drag only when moving upward (asymmetric for realism)
                if (ballFlight.velocity.y > 0) {
                    ballFlight.velocity.y *= (1 - dragFactor);
                }
            }
            
            // ====================================================================
            // POSITION UPDATE: Integrate velocity to get new position
            // ====================================================================
            // Formula: position(t+dt) = position(t) + velocity(t) * dt
            // This is Euler integration (first-order, simple but adequate)
            // ====================================================================
            
            ballFlight.position.x += ballFlight.velocity.x * dt;  // meters
            ballFlight.position.y += ballFlight.velocity.y * dt;  // meters
            ballFlight.position.z += ballFlight.velocity.z * dt;  // meters
            
            // Store trajectory point (sample every few frames to avoid too many points)
            if (ballFlight.trajectory.length === 0 || 
                ballFlight.trajectory.length % 3 === 0) {  // Every 3rd frame
                ballFlight.trajectory.push({ 
                    x: ballFlight.position.x, 
                    y: ballFlight.position.y, 
                    z: ballFlight.position.z 
                });
            }
            
            // Log first few updates for debugging
            const timeSinceLaunch = Date.now() - ballFlight.startTime;
            if (timeSinceLaunch < 200) {  // First 200ms
                const zDirection = ballFlight.position.z > 0 ? 'AWAY‚úì' : 'TOWARD‚ö†Ô∏è';
                addDebugMessage(`Physics: z=${ballFlight.position.z.toFixed(2)}m ${zDirection}`);
            }
            
            // Track maximum height (for stats)
            if (ballFlight.position.y > ballFlight.maxHeight) {
                ballFlight.maxHeight = ballFlight.position.y;
            }
            
            // ====================================================================
            // GROUND COLLISION: Check if ball hit ground
            // ====================================================================
            // Simple check: y <= 0 and moving downward
            // Real golf: Ball bounces and rolls, but we stop it for simplicity
            // ====================================================================
            
            if (ballFlight.position.y <= 0 && ballFlight.velocity.y < 0) {
                ballFlight.position.y = 0;
                ballFlight.flying = false;
                ballFlight.landingDistance = Math.sqrt(
                    ballFlight.position.x ** 2 + ballFlight.position.z ** 2
                );
                
                addDebugMessage(`‚õ≥ LANDED! ${ballFlight.landingDistance.toFixed(2)}m, h:${ballFlight.maxHeight.toFixed(2)}m`);
                
                // Update last recorded swing with final distance
                if (swingRecorder.recordedSwings.length > 0) {
                    const lastSwing = swingRecorder.recordedSwings[swingRecorder.recordedSwings.length - 1];
                    if (lastSwing.distance === 0) {
                        lastSwing.distance = ballFlight.landingDistance;
                        lastSwing.maxHeight = ballFlight.maxHeight;
                    }
                }
                
                // Check if ball never left ground
                if (ballFlight.maxHeight < 0.01) {
                    addDebugMessage(`‚ö†Ô∏è BUG: Ball never left ground! Check Y velocity at launch`);
                }
                
                // Play landing sound
                playLandSound();
                
                // Calculate impact speed
                const impactSpeed = Math.sqrt(
                    swingData.impactVelocity.x ** 2 +
                    swingData.impactVelocity.y ** 2 +
                    swingData.impactVelocity.z ** 2
                );
                
                // Save shot data
                lastShot = {
                    distance: ballFlight.landingDistance,
                    maxHeight: ballFlight.maxHeight,
                    impactSpeed: impactSpeed,
                    timestamp: new Date().toISOString()
                };
                saveToLocalStorage();
                
                currentState = GameState.SHOWING_RESULTS;
                updateStatus(`‚õ≥ Ball landed! Distance: ${ballFlight.landingDistance.toFixed(2)}m`);
            }
        }

        // ============================================
        // PART 6: VISUALIZATION & RENDERING
        // ============================================
        // PURPOSE: Draw the game state on canvas
        let lastRenderTime = 0;

        function render(timestamp) {
            const deltaTime = timestamp - lastRenderTime;
            lastRenderTime = timestamp;
            
            // Clear canvas
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground
            drawGround();
            
            // Update and draw based on state
            switch (currentState) {
                case GameState.READY_TO_SET_BALL:
                    drawClubPosition();
                    break;
                    
                case GameState.BALL_SET_READY_TO_SWING:
                    drawClubPosition();
                    // Show countdown and check timeout
                    drawCountdownTimer();
                    if (ballPosition.set) {
                        checkSwingTimeout();
                    }
                    break;
                    
                case GameState.SWINGING:
                    drawClubPosition();
                    drawSwingTrail();
                    break;
                    
                case GameState.BALL_FLYING:
                    updateBallPhysics(deltaTime);
                    drawBallTrajectory();
                    drawBall();
                    break;
                    
                case GameState.SHOWING_RESULTS:
                    drawBallTrajectory();
                    drawResults();
                    break;
            }
            
            // Draw debug info on canvas if enabled
            drawDebugInfo();
            
            // Draw swing replay if active
            if (swingRecorder.replayMode) {
                drawSwingReplay(deltaTime);
            }
            
            // Continue rendering loop
            requestAnimationFrame(render);
        }

        function drawSwingReplay(deltaTime) {
            // Get the swing to replay
            const swing = swingRecorder.recordedSwings[swingRecorder.replayIndex];
            if (!swing || !swing.tipPath || swing.tipPath.length === 0) {
                return;
            }
            
            // Update replay progress
            swingRecorder.replayProgress += (deltaTime / 1000) * swingRecorder.replaySpeed;
            const duration = (swing.endTime - swing.startTime) / 1000; // seconds
            
            // Loop replay
            if (swingRecorder.replayProgress >= duration) {
                swingRecorder.replayProgress = 0;
            }
            
            // Calculate which frame to show
            const frameIndex = Math.floor(
                (swingRecorder.replayProgress / duration) * swing.tipPath.length
            );
            
            // Draw replay overlay
            const overlayX = canvas.width * 0.05;
            const overlayY = canvas.height * 0.15;
            const overlayW = canvas.width * 0.4;
            const overlayH = canvas.height * 0.4;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(overlayX, overlayY, overlayW, overlayH);
            
            // Title
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`üìº Replay ${swingRecorder.replayIndex + 1}/${swingRecorder.recordedSwings.length}`, overlayX + 10, overlayY + 25);
            
            // Swing info
            ctx.font = '14px Arial';
            ctx.fillStyle = 'white';
            ctx.fillText(`Distance: ${swing.distance ? swing.distance.toFixed(1) + 'm' : 'N/A'}`, overlayX + 10, overlayY + 50);
            ctx.fillText(`Height: ${swing.maxHeight ? swing.maxHeight.toFixed(1) + 'm' : 'N/A'}`, overlayX + 10, overlayY + 70);
            
            // Draw swing path
            const pathX = overlayX + overlayW / 2;
            const pathY = overlayY + overlayH - 20;
            const scale = 150;
            
            // Full swing trail (faded)
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            swing.tipPath.forEach((point, i) => {
                const screenX = pathX + point.position.x * scale;
                const screenY = pathY - point.position.y * scale;
                
                if (i === 0) {
                    ctx.moveTo(screenX, screenY);
                } else {
                    ctx.lineTo(screenX, screenY);
                }
            });
            ctx.stroke();
            
            // Current position (highlighted)
            if (frameIndex < swing.tipPath.length) {
                const currentPoint = swing.tipPath[frameIndex];
                const curX = pathX + currentPoint.position.x * scale;
                const curY = pathY - currentPoint.position.y * scale;
                
                // Highlight ball
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pathX, pathY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Club tip
                ctx.fillStyle = 'lime';
                ctx.beginPath();
                ctx.arc(curX, curY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Line to ball
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pathX, pathY);
                ctx.lineTo(curX, curY);
                ctx.stroke();
            }
            
            // Progress bar
            const barX = overlayX + 10;
            const barY = overlayY + overlayH - 15;
            const barW = overlayW - 20;
            const barH = 8;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(barX, barY, barW, barH);
            
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(barX, barY, barW * (swingRecorder.replayProgress / duration), barH);
            
            // Controls hint
            ctx.fillStyle = '#aaa';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Tap ‚èπÔ∏è to stop', overlayX + overlayW / 2, overlayY + overlayH + 15);
        }

        function drawGround() {
            // Draw perspective fairway looking down the course
            const groundLine = canvas.height * groundLinePercent;
            
            // Sky
            const gradient = ctx.createLinearGradient(0, 0, 0, groundLine);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#B0E0E6');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, groundLine);
            
            // Ground/fairway
            ctx.fillStyle = '#90EE90';
            ctx.fillRect(0, groundLine, canvas.width, canvas.height - groundLine);
            
            // Draw perspective grid to show depth
            ctx.strokeStyle = 'rgba(0, 100, 0, 0.3)';
            ctx.lineWidth = 1;
            
            // Horizontal lines (distance markers) - draw from near to far
            for (let z = 0; z <= 100; z += 10) {
                // Left and right edges of fairway
                const leftPos = project3DToScreen(-5, 0, z);
                const rightPos = project3DToScreen(5, 0, z);
                
                if (leftPos.visible && rightPos.visible) {
                    ctx.beginPath();
                    ctx.moveTo(leftPos.x, leftPos.y);
                    ctx.lineTo(rightPos.x, rightPos.y);
                    ctx.stroke();
                }
            }
            
            // Vertical lines (fairway edges)
            ctx.strokeStyle = 'rgba(0, 100, 0, 0.5)';
            ctx.lineWidth = 2;
            
            // Left edge
            const nearLeft = project3DToScreen(-5, 0, 0);
            const farLeft = project3DToScreen(-5, 0, 100);
            if (nearLeft.visible || farLeft.visible) {
                ctx.beginPath();
                ctx.moveTo(nearLeft.x, nearLeft.y);
                ctx.lineTo(farLeft.x, farLeft.y);
                ctx.stroke();
            }
            
            // Right edge
            const nearRight = project3DToScreen(5, 0, 0);
            const farRight = project3DToScreen(5, 0, 100);
            if (nearRight.visible || farRight.visible) {
                ctx.beginPath();
                ctx.moveTo(nearRight.x, nearRight.y);
                ctx.lineTo(farRight.x, farRight.y);
                ctx.stroke();
            }
            
            // Center line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            const nearCenter = project3DToScreen(0, 0, 0);
            const farCenter = project3DToScreen(0, 0, 100);
            if (nearCenter.visible || farCenter.visible) {
                ctx.beginPath();
                ctx.moveTo(nearCenter.x, nearCenter.y);
                ctx.lineTo(farCenter.x, farCenter.y);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }

        function drawClubPosition() {
            // TODO: Visualize current club position/orientation
            const x = canvas.width / 2;
            const y = canvas.height / 2;
            
            // If no IMU permission yet, show instruction
            if (!imuPermissionGranted) {
                ctx.fillStyle = 'white';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üèåÔ∏è Air Golf', x, y - 90);
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#ffdd00';
                ctx.fillText('Hold phone like a golf club', x, y - 45);
                
                ctx.font = '14px Arial';
                ctx.fillStyle = '#aaa';
                ctx.fillText('(Grip it naturally - edge or screen as club face)', x, y - 20);
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#4CAF50';
                ctx.fillText('‚Üì Tap "Tee Up" below ‚Üì', x, y + 20);
                
                ctx.font = '12px Arial';
                ctx.fillStyle = '#999';
                ctx.fillText('Adjust "Phone Orientation" in Settings if needed', x, y + 45);
                
                ctx.font = 'bold 11px Arial';
                ctx.fillStyle = '#ff6666';
                ctx.fillText('‚ö†Ô∏è We take no responsibility for broken phones! üòÖüèåÔ∏è', x, y + 65);
                return;
            }
            
            // Show ball position indicator if ball is set
            if (ballPosition.set) {
                // Draw tee position (ball at origin in 3D space)
                const teePos = project3DToScreen(0, 0, 0);
                
                if (teePos.visible) {
                    const ballRadius = Math.max(8, settings.ballDiameter * teePos.scale * 0.3);
                    
                    // Draw hit zone (detection area)
                    const hitZoneRadius = Math.max(30, settings.hitZoneDiameter * teePos.scale * 0.6);
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(teePos.x, teePos.y, hitZoneRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw club tip position indicator
                    const clubTipPos = project3DToScreen(
                        clubTipTracking.tipPosition.x,
                        clubTipTracking.tipPosition.y,
                        clubTipTracking.tipPosition.z
                    );
                    
                    if (clubTipPos.visible) {
                        const tipDist = Math.sqrt(
                            clubTipTracking.tipPosition.x ** 2 +
                            clubTipTracking.tipPosition.y ** 2 +
                            clubTipTracking.tipPosition.z ** 2
                        );
                        
                        // Color based on distance from ball
                        let tipColor = 'yellow';
                        if (tipDist < settings.hitZoneDiameter / 200) {
                            tipColor = 'lime'; // In hit zone!
                        } else if (tipDist > 0.5) {
                            tipColor = 'red'; // Too far
                        }
                        
                        // Draw club tip dot
                        ctx.fillStyle = tipColor;
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(clubTipPos.x, clubTipPos.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        
                        // Draw line from ball to club tip
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.moveTo(teePos.x, teePos.y);
                        ctx.lineTo(clubTipPos.x, clubTipPos.y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    // Draw tee marker
                    ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
                    const teeHeight = Math.max(10, 15 * teePos.scale / 100);
                    ctx.fillRect(teePos.x - 1, teePos.y - teeHeight, 2, teeHeight);
                    
                    // Draw ball glow
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(teePos.x, teePos.y - teeHeight, ballRadius * 1.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw ball
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(teePos.x, teePos.y - teeHeight, ballRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Text above ball
                    ctx.fillStyle = 'yellow';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.fillText('READY', teePos.x, teePos.y - teeHeight - ballRadius - 25);
                    ctx.fillText('Swing!', teePos.x, teePos.y - teeHeight - ballRadius - 5);
                    ctx.shadowBlur = 0;
                } else {
                    // Fallback if projection fails - draw in center
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height * 0.8;
                    
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = 'yellow';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('READY - Swing!', centerX, centerY - 30);
                }
            }
            
            // Show orientation values
            ctx.fillStyle = 'white';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Œ±:${imuData.orientation.alpha.toFixed(0)}¬∞`, x, y);
            ctx.fillText(`Œ≤:${imuData.orientation.beta.toFixed(0)}¬∞`, x, y + 25);
            ctx.fillText(`Œ≥:${imuData.orientation.gamma.toFixed(0)}¬∞`, x, y + 50);
        }

        function drawCountdownTimer() {
            // Show countdown timer
            if (swingTimer.timeRemaining > 0) {
                const centerX = canvas.width / 2;
                const timerY = 120;
                
                // Determine color based on time remaining
                let timerColor = '#4CAF50'; // Green
                if (swingTimer.timeRemaining <= 3) {
                    timerColor = '#ff4444'; // Red - urgent!
                } else if (swingTimer.timeRemaining <= 5) {
                    timerColor = '#ffaa00'; // Orange - warning
                }
                
                // Draw timer background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(centerX - 80, timerY - 30, 160, 50);
                
                // Draw timer text
                ctx.fillStyle = timerColor;
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.ceil(swingTimer.timeRemaining) + 's', centerX, timerY + 5);
                
                // Flash warning when low
                if (swingTimer.timeRemaining <= 3 && Math.floor(swingTimer.timeRemaining * 2) % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 68, 68, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
        }

        function drawSwingTrail() {
            // TODO: Draw visual trail showing swing path
            // Use swingData.recordedMotion to visualize swing
            
            // Show countdown timer
            drawCountdownTimer();
            
            // Show swing power meter
            const totalAccel = Math.sqrt(
                imuData.acceleration.x ** 2 +
                imuData.acceleration.y ** 2 +
                imuData.acceleration.z ** 2
            );
            
            const meterWidth = canvas.width * 0.8;
            const meterHeight = 40;
            const meterX = canvas.width * 0.1;
            const meterY = 200;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(meterX, meterY, meterWidth, meterHeight);
            
            // Power bar
            const powerPercent = Math.min(totalAccel / 20, 1); // Scale to 20 m/s¬≤
            ctx.fillStyle = powerPercent > 0.7 ? '#ff4444' : powerPercent > 0.4 ? '#ffaa00' : '#44ff44';
            ctx.fillRect(meterX, meterY, meterWidth * powerPercent, meterHeight);
            
            // Label
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SWING POWER', canvas.width / 2, meterY - 10);
            ctx.fillText(totalAccel.toFixed(1) + ' m/s¬≤', canvas.width / 2, meterY + 28);
            
            // Draw club tip trail
            if (clubTipTracking.history.length > 1) {
                const centerX = canvas.width / 2;
                // Center of green area (same as ball position)
                const groundTop = canvas.height * 0.7;
                const centerY = groundTop + (canvas.height - groundTop) / 2;
                const scale = 100; // Scale factor for visualization
                
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                clubTipTracking.history.forEach((point, i) => {
                    const screenX = centerX + point.position.x * scale;
                    const screenY = centerY - point.position.y * scale;
                    
                    if (i === 0) {
                        ctx.moveTo(screenX, screenY);
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                });
                
                ctx.stroke();
                
                // Draw current club tip position
                if (clubTipTracking.history.length > 0) {
                    const current = clubTipTracking.history[clubTipTracking.history.length - 1];
                    const tipX = centerX + current.position.x * scale;
                    const tipY = centerY - current.position.y * scale;
                    
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(tipX, tipY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        function drawBall() {
            // Draw ball in 3D space with perspective projection
            const pos = project3DToScreen(
                ballFlight.position.x,
                ballFlight.position.y,
                ballFlight.position.z
            );
            
            // Debug: log ball position for first few frames
            const timeSinceLaunch = Date.now() - ballFlight.startTime;
            if (timeSinceLaunch < 500) {
                const growing = pos.scale > 100; // Scale increases as ball comes closer
                const direction = growing ? '‚ÜíYOU‚ö†Ô∏è' : '‚ÜíAWAY‚úì';
                addDebugMessage(`Ball: z=${ballFlight.position.z.toFixed(1)}m ${direction}`);
            }
            
            // Only draw if ball is visible
            if (!pos.visible) return;
            
            // Ball gets smaller with distance (perspective)
            const ballRadius = Math.max(3, settings.ballDiameter * pos.scale * 0.3);
            
            // Shadow on ground
            const shadowPos = project3DToScreen(
                ballFlight.position.x,
                0, // on ground
                ballFlight.position.z
            );
            
            if (shadowPos.visible) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                const shadowRadius = Math.max(2, settings.ballDiameter * shadowPos.scale * 0.25);
                ctx.ellipse(shadowPos.x, shadowPos.y, shadowRadius, shadowRadius * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ball
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, ballRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = Math.max(1, ballRadius * 0.1);
            ctx.stroke();
            
            // Distance indicator
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.font = `${Math.max(10, 12 * pos.scale / 100)}px Arial`;
            ctx.textAlign = 'center';
            const dist = Math.sqrt(
                ballFlight.position.x ** 2 +
                ballFlight.position.z ** 2
            );
            ctx.fillText(`${dist.toFixed(1)}m`, pos.x, pos.y - ballRadius - 5);
            
            // Spin curve indicator
            if (settings.spinEffect > 0 && ballFlight.spin) {
                const sidespin = ballFlight.spin.y;
                if (Math.abs(sidespin) > 20) {
                    // Draw curve arrow
                    const arrowY = pos.y + ballRadius + 15;
                    ctx.strokeStyle = sidespin > 0 ? '#ff4444' : '#4444ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    if (sidespin > 0) {
                        // Slice (curving right)
                        ctx.moveTo(pos.x - 15, arrowY);
                        ctx.quadraticCurveTo(pos.x, arrowY - 5, pos.x + 15, arrowY);
                        ctx.fillText('‚Üí', pos.x + 20, arrowY + 5);
                    } else {
                        // Hook (curving left)
                        ctx.moveTo(pos.x + 15, arrowY);
                        ctx.quadraticCurveTo(pos.x, arrowY - 5, pos.x - 15, arrowY);
                        ctx.fillText('‚Üê', pos.x - 20, arrowY + 5);
                    }
                    ctx.stroke();
                }
            }
        }

        function drawBallTrajectory() {
            // Draw the ball's flight path in 3D perspective
            if (ballFlight.trajectory.length < 2) return;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            ctx.beginPath();
            let hasStarted = false;
            
            for (let i = 0; i < ballFlight.trajectory.length; i++) {
                const point = ballFlight.trajectory[i];
                const pos = project3DToScreen(point.x, point.y, point.z);
                
                if (pos.visible) {
                    if (!hasStarted) {
                        ctx.moveTo(pos.x, pos.y);
                        hasStarted = true;
                    } else {
                        ctx.lineTo(pos.x, pos.y);
                    }
                }
            }
            
            if (hasStarted) {
                ctx.stroke();
            }
            ctx.setLineDash([]);  // Reset to solid
        }

        function drawResults() {
            // TODO: Show final statistics
            // - Total distance
            // - Max height
            // - Swing speed
            // - Swing visualization
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(centerX - 160, centerY - 160, 320, 320);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Shot Complete! üèåÔ∏è', centerX, centerY - 120);
            
            ctx.font = '20px Arial';
            ctx.fillText(`Distance: ${ballFlight.landingDistance.toFixed(2)}m`, centerX, centerY - 80);
            ctx.fillText(`Max Height: ${ballFlight.maxHeight.toFixed(2)}m`, centerX, centerY - 50);
            
            if (lastShot.impactSpeed) {
                ctx.fillText(`Impact Speed: ${lastShot.impactSpeed.toFixed(1)}m/s`, centerX, centerY - 20);
            }
            
            // Show velocity components for debugging
            ctx.font = '14px Arial';
            ctx.fillStyle = '#ffff00';
            ctx.fillText(`Launch velocity:`, centerX, centerY + 10);
            ctx.font = '16px monospace';
            ctx.fillText(`X:${ballFlight.velocity.x.toFixed(1)} Y:${ballFlight.velocity.y.toFixed(1)} Z:${ballFlight.velocity.z.toFixed(1)}`, centerX, centerY + 30);
            
            // Show spin information
            if (lastShot.spin) {
                ctx.font = '14px Arial';
                ctx.fillStyle = '#00ffff';
                const sidespin = lastShot.spin.y;
                let spinText = 'Straight';
                if (Math.abs(sidespin) > 50) {
                    if (sidespin > 0) {
                        spinText = `SLICE ‚Üí`;
                    } else {
                        spinText = `‚Üê HOOK`;
                    }
                } else if (Math.abs(sidespin) > 20) {
                    if (sidespin > 0) {
                        spinText = `Fade ‚Üí`;
                    } else {
                        spinText = `‚Üê Draw`;
                    }
                }
                ctx.fillText(`Shot Shape: ${spinText}`, centerX, centerY + 50);
            }
            
            ctx.font = '12px Arial';
            ctx.fillStyle = '#aaa';
            ctx.fillText(`(Enable Debug to see detailed logs)`, centerX, centerY + 70);
            
            // Show last shot if available
            if (lastShot.timestamp) {
                ctx.font = '14px Arial';
                ctx.fillStyle = '#aaa';
                const shotDate = new Date(lastShot.timestamp);
                ctx.fillText(`Last shot: ${shotDate.toLocaleTimeString()}`, centerX, centerY + 95);
            }
            
            ctx.font = '16px Arial';
            ctx.fillStyle = '#4CAF50';
            ctx.fillText('Tap Reset to play again', centerX, centerY + 125);
        }

        // ============================================
        // PART 7: UI UPDATES
        // ============================================
        function updateStatus(message) {
            statusDiv.textContent = 'Status: ' + message;
        }

        function drawDebugInfo() {
            if (!settings.showDebug) return;
            
            // Draw debug overlay in top-left corner
            const debugX = 10;
            const debugY = 10;
            const debugWidth = Math.min(canvas.width - 20, 400);
            const debugHeight = 250; // Fixed height
            
            // Semi-transparent background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(debugX - 5, debugY - 5, debugWidth + 10, debugHeight + 10);
            
            // Title
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('DEBUG LOG:', debugX, debugY + 15);
            
            // PERSISTENT HUD: Show current tip position (doesn't scroll)
            if (ballPosition.set) {
                const tipDist = Math.sqrt(
                    clubTipTracking.tipPosition.x ** 2 +
                    clubTipTracking.tipPosition.y ** 2 +
                    clubTipTracking.tipPosition.z ** 2
                );
                
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 11px monospace';
                ctx.fillText(`TIP: [${clubTipTracking.tipPosition.x.toFixed(2)}, ${clubTipTracking.tipPosition.y.toFixed(2)}, ${clubTipTracking.tipPosition.z.toFixed(2)}] ${tipDist.toFixed(2)}m`, debugX, debugY + 30);
            }
            
            // PERSISTENT HUD: Last shot velocity (stays visible!)
            if (lastShot.velocity) {
                ctx.fillStyle = '#ff00ff';
                ctx.font = 'bold 11px monospace';
                const spinLabel = lastShot.spin ? ` spin:${Math.abs(lastShot.spin.y).toFixed(0)}` : '';
                ctx.fillText(`LAST: V[${lastShot.velocity.x.toFixed(1)}, ${lastShot.velocity.y.toFixed(1)}, ${lastShot.velocity.z.toFixed(1)}]${spinLabel}`, debugX, debugY + 43);
            }
            
            // Debug messages (scrolling log)
            ctx.font = '11px monospace';
            ctx.fillStyle = '#00ff00';
            let lineY = debugY + 63; // Start below HUD
            const lineHeight = 14;
            
            // Reserve space for coordinate legend at bottom (55px)
            const availableHeight = debugHeight - 118; // 63 for top + HUD, 55 for bottom
            const maxLines = Math.floor(availableHeight / lineHeight);
            
            // Show last N messages that fit (most recent at bottom)
            const visibleMessages = debugLog.messages.slice(-maxLines);
            visibleMessages.forEach(msg => {
                ctx.fillText(msg, debugX, lineY);
                lineY += lineHeight;
            });
            
            // If no messages yet, show IMU data
            if (debugLog.messages.length === 0 && imuPermissionGranted) {
                ctx.fillText('Waiting for events...', debugX, lineY);
            }
            
            // Draw coordinate system indicator (bottom of debug box)
            const coordY = debugY + debugHeight - 55;
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 10px monospace';
            ctx.fillText(`MODE: ${settings.phoneOrientation === 'edge' ? 'EDGE FIRST üèåÔ∏è' : 'SCREEN FIRST üì±'}`, debugX, coordY);
            ctx.fillStyle = '#00ff00';
            ctx.font = '10px monospace';
            ctx.fillText('Screen: X=L/R Y=UP/DOWN Z=AWAY', debugX, coordY + 12);
            ctx.fillText(`Spin: ${settings.spinEffect}/10 | Side swing = Hook/Slice`, debugX, coordY + 22);
            ctx.fillText('Large |X| = slice/hook, Large Z = straight', debugX, coordY + 32);
        }

        // ============================================
        // PART 8: RESET FUNCTIONALITY
        // ============================================
        resetBtn.addEventListener('click', resetGame);
        
        // Record button - toggle recording mode
        recordBtn.addEventListener('click', function() {
            swingRecorder.isRecording = !swingRecorder.isRecording;
            
            if (swingRecorder.isRecording) {
                recordBtn.textContent = '‚è∫Ô∏è Recording ON';
                recordBtn.style.background = '#ff4444';
                updateStatus('üé• Recording mode ON - your next swing will be saved!');
            } else {
                recordBtn.textContent = 'üé• Record Swing';
                recordBtn.style.background = '';
                updateStatus('üé• Recording mode OFF');
                // Cancel any in-progress recording
                if (swingRecorder.currentRecording) {
                    swingRecorder.currentRecording = null;
                }
            }
        });
        
        // Replay button - show swing replay
        replayBtn.addEventListener('click', function() {
            if (swingRecorder.recordedSwings.length === 0) {
                updateStatus('‚ö†Ô∏è No recorded swings to replay!');
                return;
            }
            
            swingRecorder.replayMode = !swingRecorder.replayMode;
            
            if (swingRecorder.replayMode) {
                swingRecorder.replayProgress = 0;
                swingRecorder.replayIndex = swingRecorder.recordedSwings.length - 1; // Show most recent
                replayBtn.textContent = '‚èπÔ∏è Stop Replay';
                replayBtn.style.background = '#4444ff';
                updateStatus(`‚ñ∂Ô∏è Replaying swing ${swingRecorder.replayIndex + 1}/${swingRecorder.recordedSwings.length}`);
            } else {
                replayBtn.textContent = '‚ñ∂Ô∏è Replay';
                replayBtn.style.background = '';
                updateStatus('‚èπÔ∏è Replay stopped');
            }
        });

        function resetGame() {
            // TODO: Reset all state and start over
            ballPosition.set = false;
            swingData.recordedMotion = [];
            swingData.hitDetected = false;
            ballFlight.flying = false;
            ballFlight.maxHeight = 0;
            ballFlight.trajectory = [];
            swingTimer.expired = false;
            swingTimer.timeRemaining = 0;
            
            // Reset club tip tracking
            clubTipTracking.quaternion = { w: 1, x: 0, y: 0, z: 0 };
            clubTipTracking.tipPosition = { x: 0, y: 0, z: 0 };
            clubTipTracking.tipVelocity = { x: 0, y: 0, z: 0 };
            clubTipTracking.history = [];
            clubTipTracking.lastUpdateTime = 0;
            
            // Clear debug log
            debugLog.messages = [];
            addDebugMessage(`üîÑ Game reset`);
            
            currentState = GameState.READY_TO_SET_BALL;
            setBallBtn.disabled = false;
            
            if (imuPermissionGranted) {
                updateStatus('üîÑ Ready for another shot! Tap "Tee Up"');
            } else {
                updateStatus('üîÑ Reset! Tap "Tee Up" to begin');
            }
        }

        // ============================================
        // PART 9: SETTINGS MODAL
        // ============================================
        settingsBtn.addEventListener('click', openSettings);
        saveSettingsBtn.addEventListener('click', saveSettings);
        cancelSettingsBtn.addEventListener('click', closeSettings);
        
        // Update range displays
        settingsInputs.hitSensitivity.addEventListener('input', function() {
            document.getElementById('sensitivityValue').textContent = this.value;
        });
        settingsInputs.minSwingSpeed.addEventListener('input', function() {
            document.getElementById('speedValue').textContent = parseFloat(this.value).toFixed(1);
        });
        settingsInputs.swingTimeout.addEventListener('input', function() {
            document.getElementById('timeoutValue').textContent = this.value;
        });
        settingsInputs.loftAngle.addEventListener('input', function() {
            document.getElementById('loftValue').textContent = this.value;
        });
        settingsInputs.airResistance.addEventListener('input', function() {
            document.getElementById('airResValue').textContent = parseFloat(this.value).toFixed(1);
        });
        settingsInputs.impactPower.addEventListener('input', function() {
            document.getElementById('impactPowerValue').textContent = parseFloat(this.value).toFixed(1);
        });
        settingsInputs.spinEffect.addEventListener('input', function() {
            document.getElementById('spinValue').textContent = this.value;
        });
        settingsInputs.soundVolume.addEventListener('input', function() {
            document.getElementById('volumeValue').textContent = this.value;
        });
        
        function openSettings() {
            // Load current settings into inputs
            settingsInputs.phoneOrientation.value = settings.phoneOrientation;
            settingsInputs.clubLength.value = settings.clubLength;
            settingsInputs.clubWeight.value = settings.clubWeight;
            settingsInputs.loftAngle.value = settings.loftAngle;
            settingsInputs.ballDiameter.value = settings.ballDiameter;
            settingsInputs.ballWeight.value = settings.ballWeight;
            settingsInputs.hitZoneDiameter.value = settings.hitZoneDiameter;
            settingsInputs.hitSensitivity.value = settings.hitSensitivity;
            settingsInputs.minSwingSpeed.value = settings.minSwingSpeed;
            settingsInputs.swingTimeout.value = settings.swingTimeout;
            settingsInputs.gravity.value = settings.gravity;
            settingsInputs.airResistance.value = settings.airResistance;
            settingsInputs.impactPower.value = settings.impactPower;
            settingsInputs.spinEffect.value = settings.spinEffect;
            settingsInputs.showDebug.checked = settings.showDebug;
            settingsInputs.soundEnabled.checked = settings.soundEnabled;
            settingsInputs.soundVolume.value = settings.soundVolume;
            
            // Update range displays
            document.getElementById('sensitivityValue').textContent = settings.hitSensitivity;
            document.getElementById('speedValue').textContent = settings.minSwingSpeed.toFixed(1);
            document.getElementById('timeoutValue').textContent = settings.swingTimeout;
            document.getElementById('loftValue').textContent = settings.loftAngle;
            document.getElementById('airResValue').textContent = settings.airResistance.toFixed(1);
            document.getElementById('impactPowerValue').textContent = settings.impactPower.toFixed(1);
            document.getElementById('spinValue').textContent = settings.spinEffect;
            document.getElementById('volumeValue').textContent = settings.soundVolume;
            
            settingsModal.classList.add('active');
        }
        
        function saveSettings() {
            // Save all settings
            settings.phoneOrientation = settingsInputs.phoneOrientation.value;
            settings.clubLength = parseFloat(settingsInputs.clubLength.value);
            settings.clubWeight = parseFloat(settingsInputs.clubWeight.value);
            settings.loftAngle = parseFloat(settingsInputs.loftAngle.value);
            settings.ballDiameter = parseFloat(settingsInputs.ballDiameter.value);
            settings.ballWeight = parseFloat(settingsInputs.ballWeight.value);
            settings.hitZoneDiameter = parseFloat(settingsInputs.hitZoneDiameter.value);
            settings.hitSensitivity = parseFloat(settingsInputs.hitSensitivity.value);
            settings.minSwingSpeed = parseFloat(settingsInputs.minSwingSpeed.value);
            settings.swingTimeout = parseFloat(settingsInputs.swingTimeout.value);
            settings.gravity = parseFloat(settingsInputs.gravity.value);
            settings.airResistance = parseFloat(settingsInputs.airResistance.value);
            settings.impactPower = parseFloat(settingsInputs.impactPower.value);
            settings.spinEffect = parseFloat(settingsInputs.spinEffect.value);
            settings.showDebug = settingsInputs.showDebug.checked;
            settings.soundEnabled = settingsInputs.soundEnabled.checked;
            settings.soundVolume = parseFloat(settingsInputs.soundVolume.value);
            
            // Save to localStorage
            saveToLocalStorage();
            
            closeSettings();
            updateStatus('‚öôÔ∏è Settings saved!');
        }
        
        function closeSettings() {
            settingsModal.classList.remove('active');
        }
        
        // Close modal when clicking outside
        settingsModal.addEventListener('click', function(e) {
            if (e.target === settingsModal) {
                closeSettings();
            }
        });

        // ============================================
        // SUMMARY OF PARTS TO IMPLEMENT:
        // ============================================
        // [1] IMU Permission & Data Collection - ‚úÖ DONE
        // [2] IMU Data Processing - ‚úÖ DONE - Store raw data
        // [3] Ball Position Setting - ‚úÖ DONE - Visual feedback working
        // [4] Swing Detection - ‚úÖ DONE - Madgwick filter sensor fusion implemented
        // [5] Hit Detection - ‚úÖ DONE - Uses club tip position + ball radius + backswing check
        // [6] Velocity Calculation - ‚úÖ DONE - Finite difference from position history
        // [7] Ball Physics - Using settings for gravity & air resistance, tracks max height
        // [8] 3D to 2D Projection - Placeholder, needs proper camera view
        // [9] Swing Visualization - ‚úÖ DONE - Shows club tip trail and current position
        // [10] Results Display - ‚úÖ DONE - Shows distance, max height, impact speed, timestamp
        // [11] Settings System - ‚úÖ DONE - Full configuration panel with swing timeout
        // [12] Sound Effects - ‚úÖ DONE - Hit, landing, and alarm sounds with volume control
        // [13] Data Persistence - ‚úÖ DONE - Settings and last shot saved to localStorage
        // [14] Swing Timeout - ‚úÖ DONE - Countdown timer with alarm to prevent IMU drift
        // [15] Club Tip Tracking - ‚úÖ DONE - Madgwick filter + quaternion + kinematic model
    </script>
</body>
</html>
